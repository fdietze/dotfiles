" highlight current word
let g:highlighting = 0
function! HighlightCurrentWord()
    if g:highlighting == 1 && @/ =~ '^\\C\\<'.expand('<cword>').'\\>$'
        let g:highlighting = 0
        return ":silent nohlsearch\<CR>"
    endif
    let @/ = '\C\<'.expand('<cword>').'\>'
    let g:highlighting = 1
    return ":silent set hlsearch\<CR>"
endfunction

" highlight visually selected text
function! HighlightSelection()
  let pat = escape(@*, '\')
  let pat = substitute(pat, '\_s\+$', '\\s\\*', '')
  let pat = substitute(pat, '^\_s\+', '\\s\\*', '')
  let pat = substitute(pat, '\_s\+',  '\\_s\\+', 'g')
  let pat = "\\V" . escape(pat, '\"')
  let @/=pat
  let g:highlighting = 1
endfunction

" Highlight all instances of word under cursor when idle
function! AutoHighlightToggle()
    let @/ = ''
    if exists('#auto_highlight')
        au! auto_highlight
        augroup! auto_highlight
        setl updatetime=4000
        echo 'Highlight current word: off'
        return 0
    else
        augroup auto_highlight
            au!
            au CursorHold * let @/ = '\V\<'.escape(expand('<cword>'), '\').'\>'
        augroup END
        setl updatetime=200
        echo 'Highlight current word: ON'
        return 1
    endif
endfunction


function! StripTrailingSpaces()
    let _s=@/ " backup search string
    let save_cursor = getpos(".") " backup cursor
    " :silent! %s#\($\n\s*\)\+\%$##
    %s/\s\+$//e
    let @/=_s " restore search string
    call setpos('.', save_cursor) " restore cursor
endfunction

" from: http://stackoverflow.com/questions/18157501/toggle-semicolon-or-other-character-at-end-of-line
function! s:ToggleEndChar(charToMatch)
    let save_cursor = getpos(".") " backup cursor
    s/\v(.)$/\=submatch(1)==a:charToMatch ? '' : submatch(1).a:charToMatch
    call setpos('.', save_cursor) " restore cursor
    silent! call repeat#set("\<Plug>ToggleEndChar".a:charToMatch, -1)
endfunction

noremap <unique> <Plug>ToggleEndChar; :call <SID>ToggleEndChar(';')<CR>
noremap <unique> <Plug>ToggleEndChar, :call <SID>ToggleEndChar(',')<CR>

command! Johannes :call Johannes()
function! Johannes()
    nmap h <Left>
    nmap j <Down>
    nmap k <Up>
    nmap l <Right>
    vmap h <Left>
    vmap j <Down>
    vmap k <Up>
    vmap l <Right>
    nmap <Enter> :bnext<CR>
    nmap <Backspace> :bprev<CR>
    nmap Q :bdel<CR>
endfunction

" try to capture and analyze keystrokes
"
" let g:keys = ['x','v','l','c','w','k','h','g','f','q','u','i','a','e','o','s','n','r','t','d','y','p','z','b','m',',','.','j','X','V','L','C','W','K','H','G','F','Q','U','I','A','E','O','S','N','R','T','D','Y','P','Z','B','M','J','"', ':', '[', ']', '(', ')', '{', '}', '<Space>', '<Right>', '<Left>', '<Up>', '<Down>', '<Home>', '<End>']
" " TODO: '
" " TODO: Ctrl+key
" " TODO: f + key
" " TODO: disables delimitMate
" let g:keyCounts = {}
" let g:keyHistory = []
" let g:keyHistorySize = 5

" for key in g:keys
"     let g:keyCounts[key] = 0
"     let esckey = substitute(key, "<", "<lt>", "g")
"     " execute 'noremap <expr> ' . key . ' HitCommand(''' . key . ''',''' . esckey . ''')'
"     " execute 'noremap! <expr> ' . key . ' HitCommand(''' . key . ''',''' . esckey . ''')'
" endfor

" fun! HitCommand(key,esckey)
"     " echo 'char: '. a:key
"     let g:keyCounts[a:esckey] += 1
"     let g:keyHistory = g:keyHistory + [a:esckey]
"     let g:keyHistory = reverse(reverse(g:keyHistory)[:g:keyHistorySize])
"     " echo a:key .': '. g:keyCounts[a:esckey]
"     " echo sort(items(g:keyCounts),"CountCompare")[0:5]
"     echo '('.join(g:keyHistory,"").')'
"     " echo g:keyHistory
"     return a:key
" endfun

" fun! CountCompare(c1, c2)
"     return a:c2[1] - a:c1[1]
" endfun


command! -nargs=* RFZFAg
\ | execute ':Rooter'
\ | execute ':FZFAg '.<q-args>
\ | execute 'silent! lcd %:p:h'

" locate command integration
command! -nargs=1 Locate call fzf#run(
      \ {'source': 'locate <q-args>', 'sink': 'e', 'options': '-m'})

function! s:ag_to_file(line)
  let parts = split(a:line, ':')
  return parts[0] . ":" . parts[1] . ":" . parts[2]
endfunction

function! s:ag_handler(lines)
  let list = map(a:lines, 's:ag_to_file(v:val)')
  let wd = system('pwd')
  for l in a:lines
    execute 'silent! lcd ' . wd
    execute 'E ' . l
  endfor
endfunction

command! -nargs=* FZFAg call fzf#run({
\ 'source':  printf('ag --nogroup --column --color "%s"',
\                   escape(empty(<q-args>) ? '^(?=.)' : <q-args>, '"\')),
\ 'sink*':    function('<sid>ag_handler'),
\ 'options': '--ansi --multi '.
\            '--multi '
\ })

command! FZFE call fzf#run(
            \ {'sink': 'E', 'options': '-m'})

" choose colorscheme
command! FZFColorscheme call fzf#run({
\   'source':
\     map(split(globpath(&rtp, "colors/*.vim"), "\n"),
\         "substitute(fnamemodify(v:val, ':t'), '\\..\\{-}$', '', '')"),
\   'sink':    'colo',
\   'options': '+m',
\   'left':    30
\ })<CR>

" jump to tags
function! s:tags_to_file(line)
  let parts = split(a:line, '  ')
  return parts[1]
endfunction

function! s:tags_handler(lines)
  let list = map(a:lines, 's:tags_to_file(v:val)')
  for l in list
    execute 'tag ' . l
  endfor
endfunction

command! -bar FZFTags if !empty(tagfiles()) | call fzf#run({
\   'source': 'cat ' . join(tagfiles()) . ' | format_tags',
\   'sink*':   function('<sid>tags_handler'),
\   'options': '--multi',
\ }) | else | echo 'No tags' | endif

" jump to tags in current file
command! FZFTagFile if !empty(tagfiles()) | call fzf#run({
\   'source': 'cat ' . join(tagfiles()) . ' | grep "' . expand('%:p') . '" | format_tags',
\   'sink*':   function('<sid>tags_handler'),
\   'options': '--multi',
\ }) | else | echo 'No tags' | endif

" mru files
command! FZFMru call fzf#run({
            \'source': v:oldfiles,
            \'sink' : 'E',
            \'options' : '-m',
            \})

" buffer switching
function! s:buflist()
  redir => ls
  silent ls
  redir END
  return split(ls, '\n')
endfunction

function! s:bufopen(e)
  execute 'buffer' matchstr(a:e, '^[ 0-9]*')
endfunction

command! FZFBuffers call fzf#run({
\   'source':  reverse(<sid>buflist()),
\   'sink':    function('<sid>bufopen'),
\   'options': '+m',
\ })<CR>

" select lines of open buffers
function! s:line_handler(l)
  let keys = split(a:l, ':\t')
  exec 'buf' keys[0]
  exec keys[1]
  normal! ^zz
endfunction

function! s:buffer_lines()
  let res = []
  for b in filter(range(1, bufnr('$')), 'buflisted(v:val)')
    call extend(res, map(getbufline(b,0,"$"), 'b . ":\t" . (v:key + 1) . ":\t" . v:val '))
  endfor
  return res
endfunction

command! FZFLines call fzf#run({
\   'source':  <sid>buffer_lines(),
\   'sink':    function('<sid>line_handler'),
\   'options': '--extended --nth=3..'
\})

" fuzzy cmdline completion
cnoremap <silent> <c-l> <c-\>eGetCompletions()<cr>
"add an extra <cr> at the end of this line to automatically accept the fzf-selected completions.

function! Lister()
    call extend(g:FZF_Cmd_Completion_Pre_List,split(getcmdline(),'\(\\\zs\)\@<!\& '))
endfunction

function! CmdLineDirComplete(prefix, options, rawdir)
    let l:dirprefix = matchstr(a:rawdir,"^.*/")
    if isdirectory(expand(l:dirprefix))
        return join(a:prefix + map(fzf#run({
                    \'options': a:options . ' --select-1  --query=' .
                    \ a:rawdir[matchend(a:rawdir,"^.*/"):len(a:rawdir)],
                    \'dir': expand(l:dirprefix)
                    \}),
                    \'"' . escape(l:dirprefix, " ") . '" . escape(v:val, " ")'))
    else
        return join(a:prefix + map(fzf#run({
                    \'options': a:options . ' --query='. a:rawdir }),
                    \'escape(v:val, " ")'))
        "dropped --select-1 to speed things up on a long query
endfunction

function! GetCompletions()
    let g:FZF_Cmd_Completion_Pre_List = []
    let l:cmdline_list = split(getcmdline(), '\(\\\zs\)\@<!\& ', 1)
    let l:Prefix = l:cmdline_list[0:-2]
    execute "silent normal! :" . getcmdline() . "\<c-a>\<c-\>eLister()\<cr>\<c-c>"
    let l:FZF_Cmd_Completion_List = g:FZF_Cmd_Completion_Pre_List[len(l:Prefix):-1]
    unlet g:FZF_Cmd_Completion_Pre_List
    if len(l:Prefix) > 0 && l:Prefix[0] =~
                \ '^ed\=i\=t\=$\|^spl\=i\=t\=$\|^tabed\=i\=t\=$\|^arged\=i\=t\=$\|^vsp\=l\=i\=t\=$'
                "single-argument file commands
        return CmdLineDirComplete(l:Prefix, "",l:cmdline_list[-1])
    elseif len(l:Prefix) > 0 && l:Prefix[0] =~
                \ '^arg\=s\=$\|^ne\=x\=t\=$\|^sne\=x\=t\=$\|^argad\=d\=$'
                "multi-argument file commands
        return CmdLineDirComplete(l:Prefix, '--multi', l:cmdline_list[-1])
    else
        return join(l:Prefix + fzf#run({
                    \'source':l:FZF_Cmd_Completion_List,
                    \'options': '--select-1 --query='.shellescape(l:cmdline_list[-1])
                    \}))
    endif
endfunction


" edit multiple files with :E
command! -complete=file -nargs=* E call s:ETW('edit', <f-args>)
function! s:ETW(what, ...)
    if empty(a:000)
        edit
        return
    endif

    for f1 in a:000
        let files = glob(f1)
        if files == ''
            execute a:what . ' ' . escape(f1, '\ "')
        else
            for f2 in split(files, "\n")
                execute a:what . ' ' . escape(f2, '\ "')
            endfor
        endif
    endfor
endfunction
