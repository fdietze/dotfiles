let g:keys = ['x','v','l','c','w','k','h','g','f','q','u','i','a','e','o','s','n','r','t','d','y','p','z','b','m',',','.','j','X','V','L','C','W','K','H','G','F','Q','U','I','A','E','O','S','N','R','T','D','Y','P','Z','B','M','J','"', ':', '[', ']', '(', ')', '{', '}', '<Space>', '<Right>', '<Left>', '<Up>', '<Down>', '<Home>', '<End>']
" TODO: '
" TODO: Ctrl+key
" TODO: f + key
" TODO: disables delimitMate
let g:keyCounts = {}
let g:keyHistory = []
let g:keyHistorySize = 5

for key in g:keys
    let g:keyCounts[key] = 0
    let esckey = substitute(key, "<", "<lt>", "g")
    " execute 'noremap <expr> ' . key . ' HitCommand(''' . key . ''',''' . esckey . ''')'
    " execute 'noremap! <expr> ' . key . ' HitCommand(''' . key . ''',''' . esckey . ''')'
endfor

fun! HitCommand(key,esckey)
    " echo 'char: '. a:key
    let g:keyCounts[a:esckey] += 1
    let g:keyHistory = g:keyHistory + [a:esckey]
    let g:keyHistory = reverse(reverse(g:keyHistory)[:g:keyHistorySize])
    " echo a:key .': '. g:keyCounts[a:esckey]
    " echo sort(items(g:keyCounts),"CountCompare")[0:5]
    echo '('.join(g:keyHistory,"").')'
    " echo g:keyHistory
    return a:key
endfun

fun! CountCompare(c1, c2)
    return a:c2[1] - a:c1[1]
endfun

" TODO: Q (ex-mode)

let mapleader=","
let g:mapleader=","

" in NEO keyboard (http://neo-layout.org/) Layout we can remap HJKL,
" because there are arrow keys in the middle of the keyboard already.
" additionally we have ÜÖÄß

" h: Highlight current word, selection, autohighlight
nnoremap <silent> <expr> h HighlightCurrentWord()
vnoremap <silent> h :<C-U>call HighlightSelection()<CR>:set hlsearch<CR>
" toggle automatic highlighting on/off.
nnoremap <Leader>h :if AutoHighlightToggle()<Bar>set hls<Bar>endif<CR>

" j: Jump to definition (using eclim)
nnoremap  j :ScalaSearch<CR>

" k:
" (nothing yet)

" l: Open File Manager
nnoremap <silent> l :NERDTreeToggle<CR>

" ß: replay q macro
nnoremap ß @q

nnoremap ö :w<CR>
nnoremap ä :q<CR>
nnoremap ü :bd<CR>


" Smart way to move between windows, adjusted for NEO
" in insert mode
imap ∫ <C-o><C-W>h
imap ∀ <C-o><C-W>j
imap Λ <C-o><C-W>k
imap ∃ <C-o><C-W>l
" in other modes
map ∫ <C-W>h
map ∀ <C-W>j
map Λ <C-W>k
map ∃ <C-W>l

" Smart way to move between tabs, adjusted for NEO
" in insert mode
imap √ <C-o>:tabprev<cr>
imap ℂ <C-o>:tabnext<cr>
" in other modes
map √ :tabprev<cr>
map ℂ :tabnext<cr>

" NEO navigation for QWERTY
"         Arrow   Home End Del Backsp PageUpDown  Enter / Esc
" AltGr + edsf    a    g   r   w      q     t     v       y
noremap    €   <Up>
noremap!   €   <Up>
noremap    ð   <Down>
noremap!   ð   <Down>
noremap    ſ   <Left>
noremap!   ſ   <Left>
noremap    đ   <Right>
noremap!   đ   <Right>
noremap    æ   <Home>
noremap!   æ   <Home>
noremap    ŋ   <End>
noremap!   ŋ   <End>
noremap    ¶   <Del>
noremap!   ¶   <Del>
noremap    ł   <Backspace>
noremap!   ł   <Backspace>
" noremap    @   <PageUp>
" noremap!   @   <PageUp>
noremap    ŧ   <PageDown>
noremap!   ŧ   <PageDown>
noremap    „   <CR>
noremap!   „   <CR>
noremap    »   <Esc>
noremap!   »   <Esc>



" folding with + and -
noremap + za
noremap - zf

" make Y behave like D and C
map Y y$

" navigate up and down through soft wrapped lines
noremap <Up> g<Up>
inoremap <Up> <C-o>g<Up>
noremap <Down> g<Down>
inoremap <Down> <C-o>g<Down>
noremap <End> g<End>
inoremap <End> <C-o>g<End>

" smart home
noremap <expr> <silent> <Home> col('.') == match(getline('.'),'\S')+1 ? 'g0' : 'g^'
imap <silent> <Home> <C-O>g<Home>

nnoremap A g<End>a
nnoremap I g<Home>i


" Switch buffers with tab
nnoremap <silent> <Tab> :bnext<CR>
nnoremap <silent> <S-Tab> :bprevious<CR>

" Unite
" nnoremap <Leader>e :<C-u>Unite -no-split -start-insert file_rec<CR>
nnoremap <Leader>e :<C-u>CommandT<CR>
nnoremap <Leader>a :<C-u>Unite -no-split -start-insert buffer tab file_mru<CR>

" clear search highlighting and locations
nnoremap <silent> <Space> :nohlsearch<CR>:LocationListClear<CR>:lclose<CR>


" fast way to edit ~/.vimrc*
nnoremap <Leader>v :e ~/.vimrc<CR>
nnoremap <Leader>vp :e ~/.vimrc_plugins<CR>
nnoremap <Leader>vk :e ~/.vimrc_keybindings<CR>
nnoremap <Leader>vs :e ~/.vimrc_statusline<CR>

" save and quit
" nnoremap <Leader>w :wa<CR>
" nnoremap <Leader>q :q<CR>
" nnoremap <Leader>x :x<CR>

" save all and make
nnoremap <Leader>m :wa<CR>:make<CR><CR>:copen<CR>

" jump to tag (for example in help files)
nnoremap <leader>j <C-]>

" toggle distration free writing
nnoremap <silent> <leader>d :Goyo<CR>

" Toggle fullscreen for current window (Plugin ZoomWin)
noremap <silent> <c-f> :ZoomWin<CR>

" smooth scrolling (Plugin vim-smooth-scroll)
noremap <silent> <c-u> :call smooth_scroll#up(&scroll, 0, 2)<CR>
noremap <silent> <c-d> :call smooth_scroll#down(&scroll, 0, 2)<CR>
" noremap <silent> <c-b> :call smooth_scroll#up(&scroll*2, 0, 4)<CR>
" noremap <silent> <c-f> :call smooth_scroll#down(&scroll*2, 0, 4)<CR>
noremap <silent> <PageUp> :call smooth_scroll#up(&scroll*2, 0, 4)<CR>
noremap <silent> <PageDown> :call smooth_scroll#down(&scroll*2, 0, 4)<CR>

" disable arrow keys and home/end in insert mode, exit insert mode when pressed
" inoremap  <Up>     <Esc>g<Up>
" inoremap  <Down>   <Esc>g<Down>
" inoremap  <Left>   <Esc>
" inoremap  <Right>  <Esc>2<Right>
" inoremap  <Home>   <Esc><Home>
" inoremap  <End>    <Esc><End>

" dont move cursor when exiting insert mode, strange behavior: inserting
" characters in when pressing arrow keys
" inoremap <Esc> <Esc><Right>

" imap <C-Space> <C-X>

" no new line when selecting with ENTER
" inoremap <expr> <CR>    pumvisible() ? "\<C-y><CR>" : "\<CR>"

" TODO: noninvasive completion
" <ESC> takes you out of insert mode
" inoremap <expr> <Esc>   pumvisible() ? "\<C-y>\<Esc>" : "\<Esc>"
" <CR> accepts first, then sends the <CR>
" <Down> and <Up> cycle like <Tab> and <S-Tab>
" inoremap <expr> <Up>    pumvisible() ? "\<C-e>\<Up>" : "\<Up>"
" inoremap <expr> <Down>  pumvisible() ? "\<C-x>\<Down>" : "\<Down>"
" Jump up and down the list
" inoremap <expr> <C-d>   pumvisible() ? "\<PageDown>\<C-p>\<C-n>" : "\<C-d>"
" inoremap <expr> <C-u>   pumvisible() ? "\<PageUp>\<C-p>\<C-n>" : "\<C-u>"
" Automatically open and close the popup menu / preview window
" au CursorMovedI,InsertLeave * if pumvisible() == 0|silent! pclose|endif
" set completeopt=menu,preview,longest
